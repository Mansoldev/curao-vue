<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<style>
			p {
				font-size: 22px;
			}
			.reveal ul,ol {
				margin-bottom: 15px;
				display: block;
			}
			ul,ol > li {
				font-size: 20px;
			}
			a,h6 {
				font-size: 25px;
			}
			span.important {
				font-size: 25px;
				font-weight: bolder;
				color: red;
			}
			.reveal table th, .reveal table td {
				padding: 0;
			}
			.reveal table.separada th, .reveal table.separada td {
				padding-right: 20px;
			}
			.reveal pre code.small {
				max-width:800px;
			}

			.text-left {
				text-align: left;
			}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h1>CLASE 5 - VUEX</h1>
					</section>

					<section>
							<h4>¿Qué veremos en la clase?</h4>

							<ol>
								<li>ESTADO</li>
								<li>BUS</li>
								<li>VUEX</li>
							</ol>
					</section>
				</section>

				<section>
					<section>
						<h3>0 - ESTADO</h3>

						<p class="text-left">El estado es una abstracción referida a los datos de la aplicación en un momento concreto y parte del modelo.</p>

						<ul>
							<li>Si el modelo fuese: contador, entero</li>
							<li>El estado sería 1,2,3, los valores que tiene el modelo en un momento concreto</li>
						</ul>
						
						<p class="text-left">Sobre el estado:</p>
						<ul>
							<li>Suena complicado, es algo abstracto</li>
							<li>Se manipula de forma intuitiva programando</li>
							<li>Es fácil despreocuparse por él</li>
							<li>Los problemas suelen surgir cuando ya es "demasiado" tarde</li>
						</ul>
						
						<!--https://www.youtube.com/watch?v=gJUA_XNdh0I-->
					</section>

					<section>
						<h4>0.1 Problema de aplicaciones SPA grandes</h4>

						<p class="text-left">
							La componentización de la web viene a raiz de que los modelos, controladores y vistas se estaban volviendo gigantes y bastante inmanegables.
							Por ellos, cada componente ahora cuenta con su propio MVC, que está muy bien.
						</p>

						<p class="text-left">
							El problema es que es dificil compartir estados entre los componentes, si es de un padre a un hijo o de un hijo a un padre es facil.
							En la segunda clase vimos que el padre pasa props al hijo y el hijo emite eventos al padre.
						</p>

						<p class="text-left">
							Una vez va creciendo el proyecto podemos tener una jerarquía de muchos más niveles y es muy complicado comunicar cambios que avarquen 2 o más de estos.
							A parte estamos obligados a que el componente intermedio tenga que comunicarse con los componentes jerarquicos superior e inferior si quieren hablarse entre ellos.
						</p>

						<p class="text-left">Tenemos más problemas:</p>
						<ul>
							<li>El estado se encuentra distribuido.</li>
							<li>Nuestro arbol de estados no tiene porque ser igual al DOM.</li>
							<li>Es complicado tenerlo sincronizado.</li>
						</ul>
					</section>

					<section>
						<h4>0.2 Soluciones propuestas (state management):</h4>

						<p class="text-left"></p>

						<p class="text-left">Para atajar a este problema se crearon dos soluciones:</p>

						<ul>
							<li>BUS de eventos: Un componentes invisible con el que el resto de componentes pueden comunicarse independientemente de su nivel en la jerarquía.</li>
							<li>VUEX: Se centraliza el estado, se distribuye a los componentes.</li>
						</ul>

						<p class="text-left">Si se usa un bus de eventos en muchos componentes es facil perder el hilo del estado (datos)</p>
					</section>
				</section>

				<section>
					<section>
						<h3>1 - BUS</h3>

						<p class="text-left">Yo en vez de usar un bus con eventos a los qeu los componentes se suscriben, creo un bus de datos a los que acceden y guardan datos los componentes.</p>
					</section>

					<section>
						<h4>Bus como modulo js externo</h4>
					</section>

					<section>
						<h4>Bus como plugin de vue</h4>
					</section>
				</section>

				<section>
					<section>
						<h3>2 - VUEX (<a href="https://vuex.vuejs.org/">Documentación</a>)</h3>

						<p class="text-left">Es una libreria basada en flux que permite manejar el estado con conceptos simples.</p>

						<img src="img/vuex2.PNG" width="500" alt="">

						<ul>
							<li>Centraliza el estado</li>
							<li>El estado es de solo lectura y da acceso a todos los componentes a sus datos a través de sus getters.</li>
							<li>Se puede cambiar mediante mutaciones que normalmente son llamadas desde acciones.</li>
						</ul>
					</section>

					<section>
						Literalmente son 4 cosas:

						<img src="img/vuexCodigo.PNG" width="600" alt="">
					</section>

					<section>
						<h4>2.1 ESTADO:</h4>

						<img src="img/estadoT1.PNG" alt="">

						<p class="text-left">Como podemos ver son los datos en si mismos.</p>
					</section>

					<section>
						<h4>2.2 MUTACIONES:</h4>

						<ul>
							<li>Son funciones casi puras (sin efectos colaterales).</li>
							<li>Son sincronas, para que se produzcan de forma inmediata y la reactividad fluya.</li>
							<li>Pueden ser comiteadas directamente por los componentes, pero no se debería</li>
							<li>Su función es recibir datos y modificar el estado.</li>
							<li>Manejar la lógica de los datos</li>
						</ul>

						<pre class="fragment"><code class="hljs" data-trim data-line-numbers="2-6">
						mutations: {
							addActivity(state, activity) {
								state.activities.push(activity);
							},
							deleteActivity(state, activity) {
								state.activities = state.activities.filter((val) => val.id !== activity.id);
							},
						},
						</code></pre>

						<p class="text-left">Siempre reciben el estado y pueden recibir más parámetros y a partir de ellos mutarlo.</p>
					</section>

					<section>
						<h4>2.3 ACCIONES:</h4>

						<ul>
							<li>Son funciones que pueden ser asincronas.</li>
							<li>Las acciones se pueden componer, se pueden llamar entre ellas.</li>
							<li>Pueden llamar a API y commitean mutaciones.</li>
							<li>Manejan la lógica de negocio.</li>
						</ul>

						<pre class="fragment"><code class="hljs" data-trim data-line-numbers="2-6">
						actions: {
							incrementAsync ({ commit }) {
								setTimeout(() => {
								commit('increment')
								}, 1000)
							},
							addActivity({commit}, {activity}) {
								commit('addActivity', activity)
							},
						}
						</code></pre>
					</section>

					<section>
						<h4>2.4 GETTERS:</h4>

						<p class="text-left">Son estados derivados, un simil a las computed properties de los componentes.</p>

						<p class="text-left">Ejemplo, Edad: puedes guardarlo por fecha de nacimiento o entero.</p>

						<pre class="fragment"><code class="hljs" data-trim data-line-numbers="3-6,8,9,10">
						const store = new Vuex.Store({
							state: {
							  todos: [
								{ id: 1, text: '...', done: true },
								{ id: 2, text: '...', done: false }
							  ]
							},
							getters: {
							  doneTodos: state => {
								return state.todos.filter(todo => todo.done)
							  }
							}
						})
						</code></pre>
					</section>

					<section>
						<h4>2.5 RESUMEN:</h4>

						<img src="img/vuex.png" width="450" alt="">
						
						<ul>
							<li>Los componentes ya serían solo VC y se encargan de su vista.</li>
							<li>Los componentes dispathan acciones.</li>
							<li>Las acciones pueden llamar a la API y comitean mutaciones.</li>
							<li>Las mutaciones mutan el estado.</li>
							<li>El estado rederiza los componentes y mediante getters podemos adaptar el estado.</li>
						</ul>
					</section>

					<section>
						<h4>2.6 VENTAJAS EXTRA DE VUEX:</h4>

						<ul>
							<li>Te hace pensar sobre el estado.</li>
							<li>Te añade dos capas de abstracción (negocio y datos).</li>
							<li>Evita hacer de puente entre dos componentes.</li>
							<li>De repente tienes una "caché".</li>
							<li>Las store son modulables de forma fractal. Se pueden separar.</li>
							<li>Permite Hot Module Replacement con webpack*.</li>
							<li>Permite Time-traveling con las dev tools.</li>
						</ul>
					</section>

					<section>
						<h4>2.7 BUENAS PRACTICAS:</h4>

						<ul>
							<li>El estado debe modelarse pensando solo en los datos, evitando la redundancia, los getters pueden servirlo de forma más cómoda.</li>
							<li>Puede seguir existiendo estado local y comunicaciones padre-hijo, normalmente cosas puramente UI.</li>
							<li>Los componentes solo deberían comitear acciones.</li>
							<li>Las mutaciones deben centrarse solo en manipular los datos. Las acciones llevan la lógica de negocio.</li>
						</ul>
					</section>

					<section>
						<h4>2.8 MODULOS:</h4>

						https://vuex.vuejs.org/guide/modules.html
					</section>
				</section>

				<section>
					<section>
						<!--https://vuejsexamples.com/vue-todo-app-using-vuex-to-store-the-data/-->
						<h3>UN EJEMPLO PRACTICO</h3>
					</section>

					<section>
						<img src="img/gracias.webp" alt="">
					</section>
				</section>

				<section>
					FUNCIONAL:

					filter return fechas.filter((v, i, a) => a.indexOf(v) === i) // Quita duplicados
					map return this.items.map(d => d[val])
					unidades () { return this.items.reduce((prev, actual) => prev + parseInt(actual.cantidad), 0) },
					total () { return this.items.reduce((prev, actual) => prev + (actual.pvp * parseInt(actual.cantidad)), 0) }
					splice - slice - substr - substring
					Object.assign
					eliminar duplicados: fechas.filter((v, i, a) => a.indexOf(v) === i)
					Set [...new Set(this.objetos.map(x => x.categoria))] 
					let preCodigos = [...new Set(this.items.filter(x => x.TIPO == this.tipo).map(x => x.ITEMS))]
					this.codigosItems = [].concat(...preCodigos)
					http://www.etnassoft.com/2016/09/13/el-objeto-set-en-javascript-los-nuevos-arrays-en-es6-teoria-ejemplos-y-rendimiento-comparado/
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
